from typing import Any, Iterator, Iterable, Self

#region Queue

class Queue:
    def __init__(self) -> None: ...
    
    # representation methods
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    
    # integration methods
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __add__(self, other: Queue) -> Queue: ...
    def __reversed__(self) -> Queue: ...
    def __contains__(self, value: Any) -> bool: ...

    # comparaison methods
    def __eq__(self, value: object) -> bool: ...
    def __ne__(self, value: object) -> bool: ...
    def __lt__(self, value: object) -> bool: ...
    def __le__(self, value: object) -> bool: ...
    def __gt__(self, value: object) -> bool: ...
    def __ge__(self, value: object) -> bool: ...

    # bitwise methods
    def __or__(self, value: Any) -> Queue: ...
    def __ror__(self, value: Any) -> Queue: ...

    # remaining methods
    def __hash__(self) -> int: ...
    def __sizeof__(self) -> int: ...
    # Problem with doc choosen with the __new__ doc 
    # instead of Class doc.
    def __new__(cls) -> Self: 
        """
        Queue class wich represent a classic FIFO buffer.
        """
        ...

    # functions
    def len(self) -> int: ...
    def add(self, value: Any) -> None: ...
    def madd(self, value: Iterable[Any]) -> None: ...
    def sub(self) -> Any: ...
    def is_empty(self) -> bool: ...
    def remove(self, element: Any, time: int) -> None: ...
    def count(self, element: Any) -> int: ...
    def add_queue(self, queue: Queue) -> None: ...

#endregion

#region FastQueue

class Chain:
    def __init__(self, value: Any = None, link: Chain | None = None) -> None: ...
    
    # representation methods
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    # integration methods
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Any]: ...
    
    # comparaison methods
    def __eq__(self, value: object) -> bool: ...
    def __ne__(self, value: object) -> bool: ...
    def __lt__(self, value: object) -> bool: ...
    def __le__(self, value: object) -> bool: ...
    def __gt__(self, value: object) -> bool: ...
    def __ge__(self, value: object) -> bool: ...

    # other methods
    def __hash__(self) -> int: ...
    def __sizeof__(self) -> int: ...
    
    # functions
    def len(self) -> int: ...
    def set_link(self, link: Chain | None) -> None: ...
    def get_link(self) -> Chain | None: ...
    def set_value(self, value: Any | None) -> None: ...
    def get_value(self) -> Any: ...

class FastQueue:
    def __init__(self) -> None: ...
    
    # representation methods
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    
    # integration methods
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __add__(self, other: FastQueue) -> FastQueue: ...
    def __reversed__(self) -> FastQueue: ...
    def __contains__(self, value: Any) -> bool: ...

    # comparaison methods
    def __eq__(self, value: object) -> bool: ...
    def __ne__(self, value: object) -> bool: ...
    def __lt__(self, value: object) -> bool: ...
    def __le__(self, value: object) -> bool: ...
    def __gt__(self, value: object) -> bool: ...
    def __ge__(self, value: object) -> bool: ...

    # remaining methods
    def __hash__(self) -> int: ...
    def __sizeof__(self) -> int: ...
    # Problem with doc choosen with the __new__ doc 
    # instead of Class doc.
    def __new__(cls) -> Self: 
        """
        FastQueue: like the Queue class, but with a linked chains
        system.
        """
        ...

    # functions
    def len(self) -> int: ...
    def add(self, value: Any) -> None: ...
    def madd(self, value: Iterable[Any]) -> None: ...
    def sub(self) -> Any: ...
    def is_empty(self) -> bool: ...
    def remove(self, element: Any, time: int) -> None: ...
    def count(self, element: Any) -> int: ...
    def add_queue(self, fast_queue: FastQueue) -> None: ...